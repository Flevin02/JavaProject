# 面向对象第4天：

## 潜艇游戏第一天：

1. 创建6个类，创建World类并测试

## 潜艇游戏第二天：

1. 给6个类添加构造方法，并测试

## 潜艇游戏第三天：

1. 设计侦察潜艇数组、鱼雷潜艇数组、水雷潜艇数组、水雷数组、炸弹数组，并测试

2. 设计SeaObject超类，设计6个类继承超类

3. 给SeaObject设计两个构造方法，6个类分别调用

4. 将三种潜艇统一造型为SeaObject数组，并测试

   > 建议练习顺序：2、3、(1+4)

## 潜艇游戏第四天：

1. 在6个派生类中重写move()，并测试

2. 给类中成员添加访问控制修饰符(建议先修改派生类，最后修改超类)

3. 设计Images图片类

   

## 回顾：

1. 引用类型数组：

   - 区别1：给引用类型数组的元素赋值，需要new一个对象
   - 区别2：若想访问数组元素的数据，需要通过数组元素去打点

2. 继承：

   ​	代码复用、extends、超类：共有的属性和行为    派生类：特有的属性和行为

   ​    派生类可以访问派生类的+超类的，但是超类是不能访问派生类的

   ​    单一继承，传递性

   ​    java规定：构造派生类之前必须先构造超类

      - 派生类的构造方法中若没有调用超类的构造方法，则默认super()调用超类的无参构造方法

      - 派生类的构造方法中若自己调用了超类的构造方法，则不再默认提供

        > super()调用超类的构造方法，必须位于派生类构造方法的第一行

3. super：指代当前对象的超类对象

   - super.成员变量名-------------------------访问超类的成员变量
   - super.方法名()------------------------------调用超类的方法
   - super()----------------------------------------调用超类的构造方法

4. 向上造型：

   - 超类型的引用指向派生类的对象
   - 能点出来什么，看引用的类型--------------这是规定，记住就可以了



## 精华笔记：

1. 方法的重写(override/overriding)：重新写、覆盖

   - 发生在父子类中，方法名相同，参数列表相同
   - 重写方法被调用时，看对象的类型----------------------这是规定，记住就可以了
   - 遵循"两同两小一大"原则：----------------了解即可，一般都是一模一样的
     - 两同：
       - 方法名相同
       - 参数列表相同
     - 两小：
       - 派生类方法的返回值类型小于或等于超类方法的
         - void和基本类型时，必须相等
         - 引用类型时，小于或等于
       - 派生类方法抛出的异常小于或等于超类方法的---------------API时讲
     - 一大：
       - 派生类方法的访问权限大于或等于超类方法的

2. package和import：

   - package：声明包
     - 作用：避免类的命名冲突
     - 同包中的类不能同名，但不同包中的类可以同名
     - 类的全称：包名.类名
     - 建议：包名所有字母都小写，并且常常有层次结构
   - import：导入类
     - 同包中的类可以直接访问，但不同包中的类不能直接访问，若想访问：
       - 先import导入类再访问类------------建议
       - 类的全称-----------------------------------太繁琐、不建议

3. 访问控制修饰符：--------------------保护数据的安全

   - public：公开的，任何类

   - private：私有的，本类

   - protected：受保护的，本类、派生类、同包类

   - 默认的(default)：什么也不写，本类、同包类---------------------java不建议默认权限

     > 说明：
     >
     > 1. 类的访问权限，只能是public或默认的，而类中成员的访问权限，如上4种都可以
     > 2. 访问权限由低到高依次为：private<默认的<protected<public

4. static：静态的

   - 静态变量：
     - 由static修饰
     - 属于类，存储在方法区中，只有一份
     - 常常通过类名点来访问
     - 何时用：所有对象所共享的数据(图片、音频、视频等)
   - 静态方法：
     - 由static修饰
     - 属于类，存储在方法区中，只有一份
     - 常常通过类名点来访问
     - 静态方法中没有隐式this传递，不能直接访问实例成员
     - 何时用：方法的操作与对象无关(不需要访问对象的属性/对象的方法)
   - 静态块：
     - 由static修饰
     - 属于类，在类被加载期间自动执行，一个类只被加载一次，所以静态块也只执行一次
     - 何时用：加载/初始化静态资源(图片、音频、视频等)



## 笔记：

1. 方法的重写(override/overriding)：重新写、覆盖

   - 发生在父子类中，方法名相同，参数列表相同

   - 重写方法被调用时，看对象的类型----------------------这是规定，记住就可以了

     ```java
     class 餐馆{
         void 做餐(){ 做中餐 }
     }
     //1)我还是想做中餐-------------------不需要重写
     class Aoo extends 餐馆{
     }
     //2)我想改做西餐---------------------需要重写
     class Boo extends 餐馆{
         void 做餐(){ 做西餐 }
     }
     //3)我想在中餐基础之上加入西餐---------需要重写
     class Coo extends 餐馆{
         void 做餐(){
             super.做餐();
             做西餐
         }
     }
     ```

   - 遵循"两同两小一大"原则：----------------了解即可，一般都是一模一样的

     - 两同：

       - 方法名相同
       - 参数列表相同

     - 两小：

       - 派生类方法的返回值类型小于或等于超类方法的

         - void和基本类型时，必须相等

         - 引用类型时，小于或等于

           ```java
           //超类大，派生类小
           class Aoo{
               void show(){}
               double test(){ return 0.0; }
               Boo say(){ return null; }
               Aoo sayHi(){ return null; }
           }
           class Boo {
               //int show(){ return 1; } //编译错误，void时必须相等
               //int test(){ return 0; } //编译错误，基本类型时必须相等
               //Aoo say(){ return null; } //编译错误，引用类型时必须小于或等于
               Boo sayHi(){ return null; } //正确
           }
           ```

       - 派生类方法抛出的异常小于或等于超类方法的---------------API时讲

     - 一大：

       - 派生类方法的访问权限大于或等于超类方法的

2. package和import：

   - package：声明包
     - 作用：避免类的命名冲突
     - 同包中的类不能同名，但不同包中的类可以同名
     - 类的全称：包名.类名
     - 建议：包名所有字母都小写，并且常常有层次结构
   - import：导入类
     - 同包中的类可以直接访问，但不同包中的类不能直接访问，若想访问：
       - 先import导入类再访问类------------建议
       - 类的全称-----------------------------------太繁琐、不建议

3. 访问控制修饰符：--------------------保护数据的安全

   - public：公开的，任何类

   - private：私有的，本类

   - protected：受保护的，本类、派生类、同包类

   - 默认的(default)：什么也不写，本类、同包类---------------------java不建议默认权限

     > 说明：
     >
     > 1. 类的访问权限，只能是public或默认的，而类中成员的访问权限，如上4种都可以
     > 2. 访问权限由低到高依次为：private<默认的<protected<public

     ```java
     package ooday04;
     //访问控制修饰符的演示
     public class Coo {
         public int a;    //任何类
         protected int b; //本类、派生类、同包类
         int c;           //本类、同包类
         private int d;   //本类
     
         public void show(){
             a = 1;
             b = 2;
             c = 3;
             d = 4;
         }
     }
     
     class Doo{ //----------------------演示private
         public void show(){
             Coo o = new Coo();
             o.a = 1;
             o.b = 2;
             o.c = 3;
             //o.d = 4; //编译错误
         }
     }
     
     package ooday04_vis;
     import ooday04.Coo;
     public class Eoo { //------------------演示同包的
         public void show(){
             Coo o = new Coo();
             o.a = 1;
             //o.b = 2; //编译错误
             //o.c = 3; //编译错误
             //o.d = 4; //编译错误
         }
     }
     
     class Foo extends Coo{ //跨包继承------------演示protected
         public void show(){
             a = 1;
             b = 2;
             //c = 3; //编译错误
             //d = 4; //编译错误
         }
     }
     ```

4. static：静态的

   - 静态变量：

     - 由static修饰

     - 属于类，存储在方法区中，只有一份

     - 常常通过类名点来访问

     - 何时用：所有对象所共享的数据(图片、音频、视频等)

       ```java
       package ooday04;
       //static的演示
       public class StaticDemo {
           public static void main(String[] args) {
               Goo o1 = new Goo();
               o1.show();
               Goo o2 = new Goo();
               o2.show();
               Goo o3 = new Goo();
               o3.show();
               System.out.println(Goo.b); //常常通过类名点来访问
               Joo o6 = new Joo();
           }
       }
       
       //演示静态变量
       class Goo{
           int a;
           static int b;
           Goo(){
               a++;
               b++;
           }
           void show(){
               System.out.println(a+","+b);
           }
       }
       ```

   - 静态方法：

     - 由static修饰

     - 属于类，存储在方法区中，只有一份

     - 常常通过类名点来访问

     - 静态方法中没有隐式this传递，不能直接访问实例成员

     - 何时用：方法的操作与对象无关(不需要访问对象的属性/对象的方法)

       ```java
       package ooday04;
       
       //static的演示
       public class StaticDemo {
           public static void main(String[] args) {
               Hoo.test(); //常常通过类名点来访问
           }
       }
       
       //演示静态方法
       class Hoo{
           int a; //实例变量(由对象来访问)
           static int b; //静态变量(由类名来访问)
           void show(){ //有隐式this
               System.out.println(this.a);
               System.out.println(Hoo.b);
           }
           static void test(){ //没有隐式this
               //静态方法中没有隐式this传递，
               //没有this就意味着没有对象，
               //而实例变量a是必须通过对象来访问的，
               //所以如下语句发生编译错误
               //System.out.println(a); //编译错误
               System.out.println(Hoo.b);
           }
       }
       
       //演示静态方法何时用
       class Ioo{
           int a; //对象的属性
       
           //show()方法中访问了对象的属性a，意味着show()方法与对象有关，所以不适合设计为静态方法
           void show(){
               System.out.println(a);
           }
           //plus()方法中没有访问对象的属性/对象的行为，意味着plus()方法与对象无关，可以设计为静态方法
           int plus(int num1,int num2){
               int num = num1+num2;
               return num;
           }
       }
       ```

   - 静态块：

     - 由static修饰

     - 属于类，在类被加载期间自动执行，一个类只被加载一次，所以静态块也只执行一次

     - 何时用：加载/初始化静态资源(图片、音频、视频等)

       ```java
       package ooday04;
       
       //static的演示
       public class StaticDemo {
           public static void main(String[] args) {
               Joo o4 = new Joo();
               Joo o5 = new Joo();
               Joo o6 = new Joo();
           }
       }
       
       //演示静态块
       class Joo{
           static{
               System.out.println("静态块");
           }
           Joo(){
               System.out.println("构造方法");
           }
       }
       ```



## 补充：

1. 数据(成员变量)私有化(private)，行为(方法)大部分公开化(public)

2. 成员变量的分类：

   - 实例变量：没有static修饰，属于对象的，存储在堆中，有几个对象就有几份，通过对象/引用打点来访问
   - 静态变量：有static修饰，属于类的，存储在方法区中，只有一份，常常通过类名点来访问

3. 内存管理：由JVM来管理的

   - 堆：new出来的对象(包括实例变量、数组的元素)

   - 栈：局部变量(包括方法的参数)

   - 方法区：.class字节码文件(包括静态变量、所有方法)

4. 给实例变量初始化建议写在构造方法中，给静态变量初始化建议写在静态块中

5. 顺序：先package、再import、最后class

6. 明日单词：

   ```java
   1)graphics:图像/画笔
   2)PI:圆周率
   3)count:数量
   4)abstract:抽象的
   5)live:活着的
   6)dead:死了的
   7)state:状态
   8)is:是
   9)paint:画
   10)final:最终的
   ```

   
