# 5个创建型模式

## 单例模式

### 饿汉式

**不管你需不需要,只要类加载了,对象就给你创建出来**

**优点:** 这种写法比较简单, 就是在类装载的时候就完成了实例化, 避免了线程同步的问题。

**缺点:** 在类加载的时候就完成实例化,没有达到Lazy Loading的效果, 如果从始至终从未使用过这个实例, 则会造成内存的浪费。

#### 上代码


```java
/*分析: 这种方式基于ClassLoader机制避免了多线程的同步问题,
然而在类装载时就会实例化对象,在单例模式中大多属于都是调用getInstance()方法,
但是导致类装载的原因有很多种, 因此不能确定有其他的方式(或者其他的静态方法,比如在本类里面运行main方法)
导致类装载, 这时候初始化instance就没有达到Lazy Loading的效果。*/
public class Cgb {

    //私有化构造函数,防止通过外部的手段创建对象,破坏单例
    private Cgb() {};

    //创建本类的对象,并且私有化
    private static final Cgb CGB = new Cgb();

    //提供公共的方法,让外部访问
    public static Cgb getInstance() {
        return CGB;
    }

}
```
测试
```java
    public static void main(String[] args) {
        Cgb instance = Cgb.getInstance();
        Cgb instance1 = Cgb.getInstance();
        System.out.println(instance==instance1);
        System.out.println(instance.hashCode()==instance1.hashCode());
    }
```

### 懒汉式

**单例对象要在被使用的时候才会初始化**

**缺点:**多线程环境下，会出现线程安全问题

#### 正常的懒汉式

```java
public class LazyDemo1 {

    private static LazyDemo1 lazyDemo1;

    private LazyDemo1() {
        //写个打印语句,看看当前线程的名字
        System.out.println(Thread.currentThread().getName() + "跑完了");
    }

    public static LazyDemo1 getLazyDemo() {
        //如果这个对象没有被创建,才会去创建对象
        if (lazyDemo1 == null) {
            lazyDemo1 = new LazyDemo1();
        }
        return lazyDemo1;
    }



}
```

如果在单线程情况使用下这样是没问题的,但是如果是多线程情况下,问题就来了

**测试**

```java
 //测试,多线程下有没有问题
    public static void main(String[] args) {
    
        for (int i = 0; i < 10; i++) {
            new Thread(()->LazyDemo1.getLazyDemo()).start();
        }
    }
```

疯狂乱跑,牛头不对马嘴的那种

**原因**

创建对象是有一个过程的,但是在多线程的情况下,A线程进入判断过后,对象还没创建出来,这时B线程也能通过判断进入创建对象的步骤

#### DCl双重检测锁

```java
//DCL懒汉式(双重校验锁)
public class LazyDemo2 {
    private static volatile LazyDemo2 lazyDemo2;

    private LazyDemo2() {
        System.out.println(Thread.currentThread().getName() + "跑完了");
    }

    public static LazyDemo2 getLazyDemo2() {
        //第一重检验，目的是为了提高效率：当对象已经被实例化之后，线程就不需要再进行竞争锁了
        if (lazyDemo2 == null) {
            synchronized (LazyDemo2.class) {
                //进入同步代码块后再做一次校验,因为进入同步代码块之前是没有加锁的,详细解释看下面
                if (lazyDemo2 == null) {
                    lazyDemo2 = new LazyDemo2();
                    System.out.println(Thread.currentThread().getName()+lazyDemo2);
                }
            }
        }
        return lazyDemo2;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(() -> LazyDemo2.getLazyDemo2()).start();
        }
    }
}
```

第二重检验锁是为了保证线程同步，假若线程A通过了第一次判断，进入了同步代码块，但是还未执行，线程B就进来了（线程B获得CPU时间片），线程B也通过了第一次判断（线程A并未创建实例，所以B通过了第一次判断），准备进入同步代码块，假若这个时候不判断，就会存在这种情况：线程B创建了实例，此时恰好A也获得执行时间片，如果不加以判断，那么线程A也会创建一个实例，就会造成多实例的情况。

**volatile关键字的作用**

```plain
1. 可见性
2. 不保证原子性
3. 禁止指令重排
```

```java
 注意,这里使用volatile修饰单例对象是为了避免操作系统在进行LazyDemo2()这个非原子操作时指令重排序，具体步骤是：
 1.分配内存空间
 2.执行构造方法，初始化对象
 3.将对象指向该内存空间
 我们期望的步骤是 1-> 2 ->3 但是经过指令重排后可能会变成： 1-> 3 -> 2 这在单线程情况下是没有问题的，但是在多线程情况下可能会导致一个线程得到了一个空对象。

 比如： 线程A正常创建一个实例，执行了1-3，此时线程B调用getLazyDemo2()后发现对象不为空，因此会直接返回对象，但此时对象并未被初始化，所以需要用volatile关键字修饰。
```

#### 静态内部类

```java
 静态内部类实现单例模式其实是利用了类加载机制来保证初始化instance时只有一个线程

 静态内部类的优点是：外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化INSTANCE，故而不占内存
```

#### 复习静态内部类

忘了的人,自己个人自觉一点去跑一下下面的代码

```java
public class Outer {
    static {
        System.out.println("外部类 静态块 加载");
    }
    
    public static class Inner {
        static {
            System.out.println("内部类 静态块 加载");
        }

        public static void innerMethod() {
            System.out.println("内部类 静态方法 调用");
        }
    }

    public static void outerMethod() {
        System.out.println("外部类 静态方法 调用");
    }
}
```

测试一:加载静态内部类时，不会加载外部类

```java
public class Test {
    public static void main(String[] args) {
        Outer.Inner.innerMethod();
    }
}
```

测试二:加载外部类时，不会加载静态内部类

```java
public class Test {
    public static void main(String[] args) {
        Outer.outerMethod();
    }
}
```

#### 静态内部类单例

```java
//静态内部类
public class LazyDemo3 {

    public LazyDemo3() {
    }

    private static class InnerLazy {
        public static LazyDemo3 instance = new LazyDemo3();
    }
    public static LazyDemo3 getInstance(){
        return InnerLazy.instance;
    }

}
```

#### 保证线程安全

那么它是如何实现线程安全的？

```java
 首先要了解类加载过程中的最后一个阶段：即类的初始化，类的初始化阶本质就是执行类构造器的<clinit>方法。

 <clinit>方法：这不是由程序员写的程序，而是根据代码由javac编译器生成的。它是由类里面所有的类变量的赋值动作和静态代码块组成的。JVM内部会保证一个类的<clinit>方法在多线程环境下被正确的加锁同步，也就是说如果多个线程同时去进行“类的初始化”，那么只有一个线程会去执行类的<clinit>方法，其他的线程都要阻塞等待，直到这个线程执行完<clinit>方法。然后执行完<clinit>方法后，其他线程唤醒，但是不会再进入<clinit>()方法。也就是说同一个加载器下，一个类型只会初始化一次。
```

* 那么回到这个代码中，这里的静态变量的赋值操作进行编译之后实际上就是一个<clinit>代码，当我们执行getInstance方法的时候，会导致 InnerLazy类的加载，类加载的最后会执行类的初始化，但是即使在多线程情况下，这个类的初始化的<clinit>代码也只会被执行一次，所以它只会有一个实例。
* 那么再增加一句，之所以这里变量定义的时候不需要volatile，因为只有一个线程会执行具体的类的初始化代码<clinit>，也就是即使有指令重排序，因为根本没有第二个线程给你去影响，所以无所谓。
* 那么再讲细一点,是不是可以说静态内部类单例就是最完美的单例模式了呢？其实不然，静态内部类也有着一个致命的缺点，就是传参的问题，由于是静态内部类的形式去创建单例的，故外部无法传递参数进去
#### 真的安全了吗?

其实管你是DCL还是静态内部类在反射面前都一点卵用都没有

下面就来试试

```java
 //测试反射破解单列-DCL懒汉
    @Test
    void test5() throws Exception {
        Constructor<LazyDemo2> declaredConstructor = LazyDemo2.class.getDeclaredConstructor();
        declaredConstructor.setAccessible(true);
        LazyDemo2 lazyDemo21 = declaredConstructor.newInstance();
        LazyDemo2 lazyDemo22 = declaredConstructor.newInstance();
        System.out.println(lazyDemo21==lazyDemo22);

    }
    //测试反射破解单列-静态内部类懒汉
    @Test
    void test6() throws Exception {
        Constructor<LazyDemo3> declaredConstructor = LazyDemo3.class.getDeclaredConstructor();
        declaredConstructor.setAccessible(true);
        LazyDemo3 lazyDemo31 = declaredConstructor.newInstance();
        LazyDemo3 lazyDemo32 = declaredConstructor.newInstance();
        System.out.println(lazyDemo31==lazyDemo32);
    }
```

如何解决,请看下面

```java
synchronized (LazyMan.class) {
if (flag == false) {
flag = true;
} else {
throw new RuntimeException("我晓得你干坏事");
}
}
```

#### 枚举

枚举是一个特殊的类，一般表示一组常量

讲枚举之前,我们先来写一个案列,比如说,一个星期有7天这是不变的,按照以前的方式写的话,这里应该要用静态常量

#### 方式一:静态常量

```java
public class Week {
    public static final int MONDAY= 1;
    public static final int Tuesday= 2;
    public static final int Wednesday= 3;
    public static final int Thursday= 4;
    public static final int Friday= 5;
    public static final int Saturday= 6;
    public static final int Sunday = 7;
}
```

我们可以简单的表示一周的每天，但是扩展性很差，比如每到星期一心情就跟踩了狗屎一样，我想形容一下,这么写是做不到的

问:那么当基本类型不能完全描述一个东西的时候,这时需要怎么做?

答:面向对象嘛

因此就需要把这些基本类型变为对象,而且还要让它的属性定义好了过后又不能修改,而且还要方便调用,怎么做?

静态常量,它能保证内存独此一份且不能被修改

#### 方式二:类似单例模式

```java
public class Week {

    private int day;
    private String name;
    private String description;

    public static final  Week MONDAY= new Week(1,"星期一","心情跟踩了狗屎一样");
    public static final  Week Tuesdy= new Week(2,"星期二","为什么才星期二啊?");
    public static final  Week Wednesday= new Week(3,"星期三","总算过了半了");

    public Week() {
    }

    public Week(int day, String name, String description) {
        this.day = day;
        this.name = name;
        this.description = description;
    }

    public int getDay() {
        return day;
    }

    public void setDay(int day) {
        this.day = day;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }
}
```

改造成对象过后,就能添加其他的属性了,但是你不觉得很麻烦吗?些了一堆代码,又长又臭

于是,枚举诞生了

#### 方式三:枚举

第一步:去掉多余的代码,只保留需要的内容

```java
public class Weeks {
    MONDAY(1, "星期一", "心情跟踩了狗屎一样"),
    TUESDAY(2, "星期二", "为什么才星期二啊?"),
    WEDNESDAY(3, "星期三", "总算过了半了");
}
```

第二步:把class改成enum (jdk1.5的时候引入了枚举)

```java
public enum Weeks {
    MONDAY(1, "星期一", "心情跟踩了狗屎一样"),
    TUESDAY(2, "星期二", "为什么才星期二啊?"),
    WEDNESDAY(3, "星期三", "总算过了半了");
}
```

第三步:添加对应的属性

```java
  private final int DAY;
  private final String NAME;
  private final String DESCRIPTION;
```

第四步:添加构造函数

```java
    Weeks(int DAY, String NAME, String DESCRIPTION) {
        this.DAY = DAY;
        this.NAME = NAME;
        this.DESCRIPTION = DESCRIPTION;
    }
```

#### 枚举单列

```java
//枚举懒汉
public enum LazyDemo4 {
    INSTANCE;
    public LazyDemo4 getInstance(){return INSTANCE;}

}
```

## 原型模式

### 介绍

**意图：**用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

**主要解决：**在运行期建立和删除原型。

**何时使用：** 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。

**如何解决：**利用已有的一个原型对象，快速地生成和原型对象一样的实例。

**关键代码：** 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些"易变类"拥有稳定的接口。

**应用实例：** 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。

**优点：** 1、性能提高。 2、逃避构造函数的约束。

**缺点：** 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。

**使用场景：** 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。

**注意事项：**与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。

### clone()方法

clone顾名思义就是复制， 在Java语言中， clone方法被对象调用，所以会复制对象。所谓的复制对象，

首先要分配一个和源对象同样大小的空间，在这个空间中创建一个新的对象。那么在java语言中，有几

种方式可以创建对象呢？

* 使用new操作符创建一个对象

		   Student student = new Student(15, "老烟枪");

	       Student student3 = new Student(15, "老烟枪");

	

	        System.out.println(student);//cn.tedu.equals.Student@1540e19d

	        System.out.println(student3);//cn.tedu.equals.Student@677327b6

* 使用clone方法复制一个对象
```plain
	Student student2 = (Student)student.clone();
    System.out.println(student2);//cn.tedu.equals.Student@677327b6
```



那么这两种方式有什么相同和不同呢？ new操作符的本意是分配内存。程序执行到new操作符时， 首

先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，

再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完

毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。而clone在第一步

是和new相似的， 都是分配内存，调用clone方法时，分配的内存和源对象（即调用clone方法的对象）

相同，然后再使用原对象中对应的各个域，填充新对象的域， 填充完成之后，clone方法返回，一个新

的相同的对象被创建，同样可以把这个新对象的引用发布到外部。



### clone与赋值的区别

```plain
Student student = new Student(15, "老烟枪");
Student student1 = student;
System.out.println(student);//cn.tedu.equals.Student@1540e19d
System.out.println(student1);//cn.tedu.equals.Student@1540e19d
```

通过这样的操作我们只是单纯的把引用进行了复制,他们进行的任何操作都会影响到对方,比如说:

```plain
 student.age = 13;
 System.out.println("复制的对象改变属性:"+student1.age);
```

### 浅clone和深clone(Shallow Clone与Deep Clone)

主要是JAVA里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用，我们有时候不希望在

方法里将参数改变，这是就需要在类中复写clone方法（实现深复制）。

Clone是如何完成的呢？Object在对某个对象实施Clone时对其是一无所知的，它仅仅是简单地执行域对域的copy，这就是Shallow Clone。这样，问题就来了咯。

比如一个类里有个引用对象Date,它和原始对象中对应的域指向同一个Date对象，这样克隆类就和原始类共享了一部分信息，而这样显然

是不利的,这个时候我们就需要进行deep Clone了，对那些非基本类型的域进行特殊的处理

String很特殊,因为它是存在常量池里的,而且它本身的值也不能被修改,你以为你修改了,其实是开辟了新的空间,指向了新的地址

### 浅克隆

#### 写一个类实现Cloneable接口

```java
package cn.bs.prototype.shallow;
import java.util.Date;
//原型
//1.实现Cloneable接口
//重写clone方法
public class Pig implements Cloneable {
    private int age ;
    private Double money;
    private Date date;
    private String name;
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
    public Pig() {
    }
    public Pig(int age, Double money, Date date, String name) {
        this.age = age;
        this.money = money;
        this.date = date;
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public Double getMoney() {
        return money;
    }
    public void setMoney(Double money) {
        this.money = money;
    }
    public Date getDate() {
        return date;
    }
    public void setDate(Date date) {
        this.date = date;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return "Pig{" +
                "age=" + age +
                ", money=" + money +
                ", date=" + date +
                ", name='" + name + '\'' +
                '}';
    }
}
```

#### 测试浅克隆

```java
package cn.bs.prototype.shallow;
import java.util.Date;
//克隆
public class Pig2 {
    public static void main(String[] args) throws CloneNotSupportedException {
        //原型对象
        Date date = new Date();
        Pig pig = new Pig(12,32.5,date,"八戒");
        System.out.println("原型对象:"+pig);
        //克隆对象
        Pig clonePig = (Pig)pig.clone();
        System.out.println("克隆对象:"+clonePig);
        //测试浅克隆
        //原型对象修改属性值
        pig.setAge(15);
        pig.setMoney(100.3);
        date.setTime(123161);
        pig.setName("悟能");
        System.out.println("原型对象的年龄:"+pig.getAge());
        System.out.println("克隆对象的年龄:"+clonePig.getAge());
        System.out.println("原型对象的价格:"+pig.getMoney());
        System.out.println("克隆对象的价格:"+clonePig.getMoney());
        System.out.println("原型对象的生产时间:"+pig.getDate());
        System.out.println("克隆对象的生产时间:"+clonePig.getDate());
        System.out.println("原型对象的名字:"+pig.getName());
        System.out.println("克隆对象的名字:"+clonePig.getName());
    }
}
```

### 深克隆

#### 写一个类实现Cloneable接口

```java
import java.util.Date;

//原型
//1.实现Cloneable接口

public class Pig implements Cloneable {
    private int age ;
    private Double money;
    private Date date;

//重写clone方法---这里就是深克隆的关键
    @Override
    protected Object clone() throws CloneNotSupportedException {
        Object obj = super.clone();

        //实现深克隆 最好的办法:序列化或者反序列化 但是效率低
        Pig pig = (Pig) obj;
        //将对象的属性也进行克隆
        pig.date = (Date) this.date.clone();
        return obj;
    }

    @Override
    public String toString() {
        return "Pig{" +
                "age=" + age +
                ", money=" + money +
                ", date=" + date +
                '}';
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Double getMoney() {
        return money;
    }

    public void setMoney(Double money) {
        this.money = money;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }

    public Pig(int age, Double money, Date date) {
        this.age = age;
        this.money = money;
        this.date = date;
    }
}
```

### 测试深克隆

```java
import java.util.Date;

//克隆
public class Pig2 {
    public static void main(String[] args) throws CloneNotSupportedException {
        //原型对象
        Date date = new Date();
        Pig pig = new Pig(12,32.5,date);
        System.out.println("原型对象:"+pig);

        //克隆对象
        Pig clonePig = (Pig)pig.clone();
        System.out.println("克隆对象:"+clonePig);

        //测试浅克隆
        //原型对象修改属性值
        pig.setAge(15);
        pig.setMoney(100.3);
        date.setTime(156465);
        System.out.println("原型对象的年龄:"+pig.getAge());
        System.out.println("克隆对象的年龄:"+clonePig.getAge());

        System.out.println("原型对象的价格:"+pig.getMoney());
        System.out.println("克隆对象的价格:"+clonePig.getMoney());

        System.out.println("原型对象的生产时间:"+pig.getDate());
        System.out.println("克隆对象的生产时间:"+clonePig.getDate());

    }

}
```

## 工厂模式

工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

![图片](data:image/png;base64,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)


## 介绍

**意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

**主要解决：**主要解决接口选择的问题。

**何时使用：**我们明确地计划不同条件下创建不同实例时。

**如何解决：**让其子类实现工厂接口，返回的也是一个抽象的产品。

**关键代码：**创建过程在其子类执行。

**应用实例：** 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。

**优点：** 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。

**缺点：**每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

**使用场景：** 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。

**注意事项：**作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。

## 作用

实现了创建者与调用者的分离

### 核心

实例化对象不适用new,用工厂方法代替

将选择实现类,创建对象统一管理和控制,从而将调用者跟我们的实现类解耦

### 三种模式

**简单工厂模式**

用来生产同一等级结构中的任意产品(对于增加新的产品,需要覆盖已有代码)

**工厂方法模式**

用来生产同一等级结构中的固定产品(支持增加任意产品)

**抽象工厂模式**

围绕一个超级工厂创建其他工厂,该超级工厂又称为其他工厂的工厂

## 上代码--简单工厂模式

写一个玩具接口

```plain
public interface Toy {
    void name();
}
```

写两个实现类

```plain
public class Ultraman implements Toy{
    @Override
    public void name() {
        System.out.println("奥特曼");
    }
}
```

```plain
public class Godzilla implements Toy{
    @Override
    public void name() {
        System.out.println("哥斯拉");
    }
}
```

普通方式创对象

```plain
public class Consumer {
    public static void main(String[] args) {
        //了解接口,了解所有的实现类,等于我们要自己去制作玩具
        //真实情况是花钱就能买,工厂帮我们做
        Toy ultraman = new Ultraman();
        Toy godzilla = new Godzilla();
        ultraman.name();
        godzilla.name(); 
    }
}
```

工厂创对象---创建一个工厂类,写一个静态方法,用于创对象

```plain
//静态工厂模式
//增加一个新的对象,必须修改代码
//遵循开闭原则
public class ToyFactory {
    public static Toy getToy(String toy){
        if (toy.equals("哥斯拉")){
            return new Godzilla();
        }else if (toy.equals("奥特曼")){
            return new Ultraman();
        }else {
            return null;
        }
    }
}
```

调用静态方法创对象

```plain
   //现在就让工厂帮我们创建
        Toy u = ToyFactory.getToy("奥特曼");
        Toy g = ToyFactory.getToy("哥斯拉");
        u.name();
        g.name();
```

### 问题分析

如果我们还想创建一个对象,那么就需要在工厂里修改或者添加代码,这违背了我们oop的开闭原则

## 工厂方法模式

写一个玩具接口

```plain
public interface Toy {
    void name();
}
```

写两个实现玩具接口的类

```plain
public class Godzilla implements Toy {
    @Override
    public void name() {
        System.out.println("哥斯拉");
    }
}
```

```plain
public class Ultraman implements Toy {
    @Override
    public void name() {
        System.out.println("奥特曼");
    }
}
```

写一个玩具工厂接口

```plain
public interface ToyFactory {
    Toy getToy();
}
```

写两个实现玩具接口的类

```plain
//每一个玩具都有自己的工厂
public class GodzillaF implements ToyFactory {
    @Override
    public Toy getToy() {
        return new Godzilla();
    }
}
```

```plain
//每一个玩具都有自己的工厂
public class UltramanF implements ToyFactory {
    @Override
    public Toy getToy() {
        return new Ultraman();
    }
}
```

测试

```plain
public class Consumer {
    public static void main(String[] args) {
        Toy toy1 = new GodzillaF().getToy();
        Toy toy2 = new UltramanF().getToy();
        toy1.name();
        toy2.name();
    }
}
```

### 问题分析

在增加新的产品时,虽然没有更改原本的代码,但是对应的工厂类会越来越多,代码量冗杂

### 简单工厂和工厂方法模式作比较

结构复杂度

代码复杂度

编程复杂度

管理复杂度

**选简单工厂**

#### 总结

根据设计原则:工厂方法模式

根据实际业务:简单工厂模式

## 抽象工厂模式

抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

## 介绍

**意图：**提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

**主要解决：**主要解决接口选择的问题。

**何时使用：**系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。

**如何解决：**在一个产品族里面，定义多个产品。

**关键代码：**在一个工厂里聚合多个同类产品。

**应用实例：**工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。

**优点：**当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

**缺点：**产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。

**使用场景：** 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。

**注意事项：**产品族难扩展，产品等级易扩展。

### 定义

抽象工厂模式提供了一个创建一系列相关或者相互依赖对象的接口,无需指定它们具体的类

### 使用场景

* 不依赖与产品类实例如何被创建,实现等细节
* 强调一系列相关的产品对象(属于同一产品族)一起使用创建对象需要大量的重复代码
* 提供一个产品类的库,所有的产品以同样的接口出现,从而使得应用层不依赖于具体的实现
### 优点

* 具体产品在应用层的代码隔离,无需关心创建的细节
* 将一个系列的产品统一到一起创建
### 缺点

* 规定了所有可能被创建的产品集合,产品族中扩展新的产品困难
* 增加了系统的抽象性和理解难度
### 上代码

#### 写两个接口,用来规范实现类的内容

```plain
//手机产品接口
public interface PhoneProduct {
    void start();
    void shutdown();
    void play();
    void talk();
}
```

```plain
//电脑产品接口
public interface ComputerProduct {
    void start();
    void shutdown();
    void play();
    void work();
}
```

#### 搞两个品牌方来具体规划这两种东西的参数,即实现类

```plain
//外星人电脑参数
public class AlienComputer implements ComputerProduct {
    @Override
    public void start() {
        System.out.println("外星人电脑开机");
    }

    @Override
    public void shutdown() {
        System.out.println("外星人电脑关机");
    }

    @Override
    public void play() {
        System.out.println("外星人电脑打游戏");
    }

    @Override
    public void work() {
        System.out.println("外星人电脑工作");
    }
}
```

```plain
//外星人手机参数
public class AlienPhone implements PhoneProduct {
    @Override
    public void start() {
        System.out.println("外星人手机开机");
    }

    @Override
    public void shutdown() {
        System.out.println("外星人手机关机");
    }

    @Override
    public void play() {
        System.out.println("外星人手机玩游戏");
    }

    @Override
    public void talk() {
        System.out.println("外星人手机打电话");
    }
}
```

```plain
//苹果电脑参数
public class AppleComputer implements ComputerProduct {
    @Override
    public void start() {
        System.out.println("苹果电脑开机");
    }

    @Override
    public void shutdown() {
        System.out.println("苹果电脑关机");
    }

    @Override
    public void play() {
        System.out.println("苹果电脑打游戏");
    }

    @Override
    public void work() {
        System.out.println("苹果电脑工作");
    }
}
```

```plain
//苹果手机参数
public class ApplePhone implements PhoneProduct {
    @Override
    public void start() {
        System.out.println("苹果手机开机");
    }

    @Override
    public void shutdown() {
        System.out.println("苹果手机关机");
    }

    @Override
    public void play() {
        System.out.println("苹果手机打游戏");
    }

    @Override
    public void talk() {
        System.out.println("苹果手机打电话");
    }
}
```

#### 创建抽象工厂--写个生产工厂接口--超级工厂用来规范生产什么东西

```plain
//抽象产品工厂
public interface ProductFactory {

    //生产电脑
    ComputerProduct computerProduct();

    //生产手机
    PhoneProduct phoneProduct();

}
```

#### 创建两个品牌工厂实现超级工厂规定的内容--实现类

```plain
//外星人工厂
public class AlienFactory implements ProductFactory {
    @Override
    public ComputerProduct computerProduct() {
        return new AlienComputer();
    }

    @Override
    public PhoneProduct phoneProduct() {
        return new AlienPhone();
    }
}
```

```plain
//苹果工厂
public class AppleFactory implements ProductFactory {
    @Override
    public ComputerProduct computerProduct() {
        return new AppleComputer();
    }

    @Override
    public PhoneProduct phoneProduct() {
        return new ApplePhone();
    }
}
```

#### 测试

```plain
public class Test1 {
    public static void main(String[] args) {
        System.out.println("-----外星人系列产品-------");
        
        //创建外星人工厂
        AlienFactory alienFactory = new AlienFactory();

        //生产手机
        PhoneProduct alienP = alienFactory.phoneProduct();
        //生产电脑
        ComputerProduct alienC = alienFactory.computerProduct();

        alienP.play();
        alienP.shutdown();
        alienC.shutdown();
        alienC.work();

    }
}
```

## 总结

**简单工厂模式(静态工厂模式)**

虽然某种程度上不符合设计原则,但是实际使用最多

**工厂方法模式**

不修改已有类的前提下,通过增加新的工厂类实现扩展,可以增加产品

**抽象工厂模式**

不可以增加产品,但可以增加产品族,一般用于稳定的情况

**其实你们现在已经体验过工厂模式带来的方便了**,比如说:

反射中Class对象的newInstance方法

之后的JDBC中的Connection对象的获取,使用会话工厂(SqlSessionFactory)以及Spring中IOC容器管理创建bean对象等等

到时候你们再回过头来看这个工厂模式将会有不一样的体验

## 建造者模式

建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。定义:将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示

建造者（Builder）模式的主要角色如下。

1. 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。
2. 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。
3. 具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。
4. 指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。


## 介绍

**意图：**将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。

**主要解决：**主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。

**何时使用：**一些基本部件不会变，而其组合经常变化的时候。

**如何解决：**将变与不变分离开。

**关键代码：**建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。

**应用实例：** 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 2、JAVA 中的 StringBuilder。

**优点：** 1、建造者独立，易扩展。 2、便于控制细节风险。

**缺点：** 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。

**使用场景：** 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。

**注意事项：**与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。

## 使用场景

这个就非常重要了，因为如果你学了个东西，都不知道用来解决什么问题，你说有什么用？理解使用场景的的重要性要远高于你是不是会实现这个模式，因为只要你知道什么问题可以使用builder模式来解决，那你即使不会写，也可以在调查相关资料后完成。 我不想说一些大而正确的术语来把你搞蒙，我们只针对具体的问题，至于延展性的思考，随着你知识的增长，逐渐会明白的。

**当一个类的构造函数参数个数超过4个，而且这些参数有些是可选的参数，考虑使用构造者模式。**

**主要作用:**

* 在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象
* 用户只需要给出指定复杂对象的类型和内容,建造者模式负责按顺序创建复杂对象(把内部的建造过程和细节隐藏起来)
**例子:**

* 工厂(建造者模式):高端定制厂商负责制造玩具(具体怎么做的细节那是别人工厂的知识产权)
* 消费者:你只需要说明你需要什么样的玩具就行,工厂会给你定制
## 上代码

写一个抽象建造类Builder--用来规范具体工厂生产的内容

```java
//抽象的建造者
public abstract class Builder {

    abstract void build1(); //原材料-->硅胶
    abstract void build2(); //制作零部件-->老烟枪手办的零部件
    abstract void build3(); //底座-->纯金
    abstract void build4(); //上色-->黢黑

    //得到产品
    abstract Product getProduct();

}
```

写一个产品类Product--用来规范具体产品的属性

```java
//具体的产品:玩具
public class Product {
    private String build1;
    private String build2;
    private String build3;
    private String build4;



    public String getBuild1() {
        return build1;
    }

    public void setBuild1(String build1) {
        this.build1 = build1;
    }

    public String getBuild2() {
        return build2;
    }

    public void setBuild2(String build2) {
        this.build2 = build2;
    }

    public String getBuild3() {
        return build3;
    }

    public void setBuild3(String build3) {
        this.build3 = build3;
    }

    public String getBuild4() {
        return build4;
    }

    public void setBuild4(String build4) {
        this.build4 = build4;
    }

    @Override
    public String toString() {
        return "Product{" +
                "build1='" + build1 + '\'' +
                ", build2='" + build2 + '\'' +
                ", build3='" + build3 + '\'' +
                ", build4='" + build4 + '\'' +
                '}';
    }

}
```

写一个具体工厂类Factory--用来实现Builder的内容

```java
//具体实现工厂
public class Factory extends Builder {

    private Product product;

    public Factory() {
        this.product = new Product();
    }

    @Override
    void build1() {
        product.setBuild1("硅胶");
        System.out.println(product.getBuild1());
    }

    @Override
    void build2() {
        product.setBuild2("老烟枪手办的零部件");
        System.out.println(product.getBuild2());
    }

    @Override
    void build3() {
        product.setBuild3("纯金");
        System.out.println(product.getBuild3());
    }

    @Override
    void build4() {
        product.setBuild4("黢黑");
        System.out.println(product.getBuild4());
    }

    @Override
    Product getProduct() {
        return product;
    }



}
```

写一个指挥类(策划)Director--用来指挥具体的生产流程

```java
//指挥者(策划)-->指挥具体的生产流程
public class Director {
    public Product build(Builder builder) {
        builder.build1();
        builder.build2();
        builder.build3();
        builder.build4();

        return builder.getProduct();
    }
}
```

### 总结一下

上面的是建造者(Bilder)模式的常规用法,指挥者Director具有很重要的作用,它用于指挥具体构建者Factory如何构建产品,控制调用先后次序,并向调用者返回完整的产品类,但是有些情况下需要简化系统结构,可以把指挥者和抽象建造者Builder进行结合

#### 怎么做?

通过静态内部类方式实现零件无序装配构造,这种方式使用更加灵活,更符合定义

内部有复杂对象的默认实现,使用时可以根据用户需求自由定义更改内容,并且无需改变具体的构造方式,从而生产出不同的复杂的产品

**看不懂了?**   举个例子

你去吃饭,是不是直接跟老板说,你想吃什么,然后老板给你做就行了

中间是不是少了指挥者?你变成了指挥者

直接就是客户和具体实现者沟通

少了中间商赚差价,是不是价格更低了?产品的创建更加灵活简单了?

所以,有朋友想学习,就及时的告诉我,不要让他们网上留电话咨询

这就是口碑,懂了塞?

## 上代码

写一个抽象建造类Builder--用来规范具体工厂生产的内容

```java
//抽象的建造者 -->你想吃什么你就告诉老板
public abstract class Builder {

    abstract Builder build1(String msg);//酱肉丝
    abstract Builder build2(String msg);//蒜苗回锅
    abstract Builder build3(String msg);//米饭
    abstract Builder build4(String msg);//番茄蛋花汤
    abstract Product getProduct();

}
```

写一个产品类Product--用来规范具体产品的属性

```java
//具体的产品--吃什么?
public class Product {

    private String build1;
    private String build2;
    private String build3;
    private String build4;

    public String getBuild1() {
        return build1;
    }

    public void setBuild1(String build1) {
        this.build1 = build1;
    }

    public String getBuild2() {
        return build2;
    }

    public void setBuild2(String build2) {
        this.build2 = build2;
    }

    public String getBuild3() {
        return build3;
    }

    public void setBuild3(String build3) {
        this.build3 = build3;
    }

    public String getBuild4() {
        return build4;
    }

    public void setBuild4(String build4) {
        this.build4 = build4;
    }

    @Override
    public String toString() {
        return "Product{" +
                "build1='" + build1 + '\'' +
                ", build2='" + build2 + '\'' +
                ", build3='" + build3 + '\'' +
                ", build4='" + build4 + '\'' +
                '}';
    }

}
```

写一个具体工厂类Factory--用来实现Builder的内容

```java
public class Factory extends Builder{

    private Product product;

    public Factory() {
        this.product =new Product();
    }

    @Override
    Builder build1(String msg) {
        product.setBuild1(msg);
        return this;
    }

    @Override
    Builder build2(String msg) {
        product.setBuild2(msg);
        return this;
    }

    @Override
    Builder build3(String msg) {
        product.setBuild3(msg);
        return this;
    }

    @Override
    Builder build4(String msg) {
        product.setBuild4(msg);
        return this;
    }

    @Override
    Product getProduct() {
        return product;
    }
}
```

测试

```java
import org.junit.jupiter.api.Test;

public class Test2 {



    @Test
    public void f1(){
        //老板:吃什么? 你:不晓得,你随便搞吧
        Factory factory = new Factory();
        Product product = factory.getProduct();
        System.out.println(product.toString());
    }

    @Test
    public void f2(){
        //老板:吃什么? 你:啤酒 白酒 红酒 红牛
        Factory factory = new Factory();
        Product product = factory.build1("啤酒").build2("白酒").build3("红酒").build4("红牛").getProduct();
        System.out.println(product.toString());
    }

    @Test
    public void f3(){
        //老板:吃什么? 你:啤酒 白酒 红酒 红牛
        Factory factory = new Factory();
        Product product = factory.build1("辣条").build2("果冻").getProduct();
        System.out.println(product.toString());
    }



}
```

### 优化--静态内部类

**怎么做?**

1. 在Computer 中创建一个静态内部类 Builder，然后将Computer 中的参数都复制到Builder类中。
2. 在Computer中创建一个private的构造函数，参数为Builder类型
3. 在Builder中创建一个`public`的构造函数，参数为Computer中必填的那些参数，cpu 和ram。
4. 在Builder中创建设置函数，对Computer中那些可选参数进行赋值，返回值为Builder类型的实例
5. 在Builder中创建一个`build()`方法，在其中构建Computer的实例并返回
```java
package cn.bs.builder.demo3;

public class Computer {
    private final String cpu;//必须
    private final String ram;//必须
    private final int usbCount;//可选
    private final String keyboard;//可选
    private final String display;//可选

    private Computer(Builder builder){
        this.cpu=builder.cpu;
        this.ram=builder.ram;
        this.usbCount=builder.usbCount;
        this.keyboard=builder.keyboard;
        this.display=builder.display;
    }

    @Override
    public String toString() {
        return "Computer{" +
                "cpu='" + cpu + '\'' +
                ", ram='" + ram + '\'' +
                ", usbCount=" + usbCount +
                ", keyboard='" + keyboard + '\'' +
                ", display='" + display + '\'' +
                '}';
    }

    public static class Builder{
        private String cpu;//必须
        private String ram;//必须
        private int usbCount;//可选
        private String keyboard;//可选
        private String display;//可选

        public Builder(String cup,String ram){
            this.cpu=cup;
            this.ram=ram;
        }

        public Builder setUsbCount(int usbCount) {
            this.usbCount = usbCount;
            return this;
        }
        public Builder setKeyboard(String keyboard) {
            this.keyboard = keyboard;
            return this;
        }
        public Builder setDisplay(String display) {
            this.display = display;
            return this;
        }
        public Computer build(){
            return new Computer(this);
        }
    }
    //省略getter方法
}

```






通过前面的学习，我们已经了解了建造者模式，那么它和工厂模式有什么区别呢？

* 建造者模式更加注重方法的调用顺序，工厂模式注重创建对象。
* 创建对象的力度不同，建造者模式创建复杂的对象，由各种复杂的部件组成，工厂模式创建出来的对象都一样
* 关注重点不一样，工厂模式只需要把对象创建出来就可以了，而建造者模式不仅要创建出对象，还要知道对象由哪些部件组成。
* 建造者模式根据建造过程中的顺序不一样，最终对象部件组成也不一样。
# 结构型模式-7个

## 适配器模式

适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。

这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。

### 介绍

**意图：**将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

**主要解决：**主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。

**何时使用：** 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）

**如何解决：**继承或依赖（推荐）。

**关键代码：**适配器继承或依赖已有的对象，实现想要的目标接口。

**应用实例：** 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。

**优点：** 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。

**缺点：** 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。

**使用场景：**有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。

**注意事项：**适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。

### 上代码

#### 类继承的方式

写一个内存卡接口

```plain
//要被适配的类:内存卡
public interface SD {

    //内存卡有读写功能
     void readAndWrite();

}
```

写两个实现类

```plain
public class SumSD implements SD{
    @Override
    public void readAndWrite() {
        System.out.println("读写学习资料");
    }
}
```

```plain
public class KingSD implements SD{
    @Override
    public void readAndWrite() {
        System.out.println("读写《如何获得富婆芳心》");
    }
}
```

写一个读卡器接口

```plain
//读卡器
public interface CardReader {

    //把内存卡插进去,它可以插入电脑
    void insert();

}
```

写一个实现类

```plain
//继承的方式(类适配器,只能单继承)
//这就有点霸道了,读卡器又不是一次性的,怎么可能只能插一张内存卡



//搞个达内牌读卡器             把内存卡插进去
public class TeduCardReader extends SumSD implements CardReader{
    @Override
    public void insert() {
        super.readAndWrite(); //读卡器现在有了内存卡
    }
}
```

写一个电脑类

```plain
//客户端类:电脑
public class Computer {

    //想看内存卡里面的东西,但是没读卡器
    public void explore(CardReader cardReader){
            cardReader.insert();
    }
}
```

测试

```plain
 @Test
    public void Test1(){
        //电脑
        Computer computer = new Computer();
        //内存卡
        SD sd = new SumSD();
        //读卡器
        TeduCardReader teduCardReader = new TeduCardReader();

        computer.explore(teduCardReader);
    }
```

以上方式耦合性太强,不常使用,所以下面进行优化

#### 对象的方式(对象适配器)

```plain
//对象的方式(对象适配器:常用)



public class TeduCardReader2 implements CardReader{

    //谁有读写的功能? 内存卡对吧? 所以把内存卡这个对象拿到
    private  SD sd;

    //把内存卡放进读卡器
    public TeduCardReader2(SD sd) {
        this.sd = sd;
    }

    @Override
    public void insert() {
        sd.readAndWrite(); //电脑之后只需要调用这个方法不就能读取内存卡的数据了么
    }

    //静态方法获取对象
    public static TeduCardReader2 getCardReader(SD sd){
        return new TeduCardReader2(sd);
    }

}
```

测试

```plain
    @Test
    public void Test2() {
        //电脑
        Computer computer = new Computer();
        //内存卡
        SD sumSD = new SumSD();
        SD kingSD = new KingSD();
        //读卡器
        TeduCardReader2 teduCardReader2 = new TeduCardReader2(sumSD);
        TeduCardReader2 cardReader = TeduCardReader2.getCardReader(kingSD);
        computer.explore(teduCardReader2);
        computer.explore(cardReader);
    }
```

用这种的方式解耦,增强扩展性,在这里我们又感受到了继承的弊端

