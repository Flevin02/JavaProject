# 面向对象第5天：

## 潜艇游戏第一天：

1. 创建6个类，创建World类并测试

## 潜艇游戏第二天：

1. 给6个类添加构造方法，并测试

## 潜艇游戏第三天：

1. 设计侦察潜艇数组、鱼雷潜艇数组、水雷潜艇数组、水雷数组、炸弹数组，并测试

2. 设计SeaObject超类，设计6个类继承超类

3. 给SeaObject设计两个构造方法，6个类分别调用

4. 将三种潜艇统一造型为SeaObject数组，并测试

   > 建议练习顺序：2、3、(1+4)

## 潜艇游戏第四天：

1. 在6个派生类中重写move()，并测试

2. 给类中成员添加访问控制修饰符(建议先修改派生类，最后修改超类)

3. 设计Images图片类


## 潜艇游戏第五天：

1. 设计窗口的宽和高为常量，适当地方做修改

2. 画窗口：--------在World类中共3步，不需要掌握，CV大法即可

   - import JFrame+JPanel
   - 设计World类继承JPanel----------------这一步大家特别容易忘记
   - main中代码CV大法

3. 画对象：---------------------------------要求：看着笔记中的步骤能写出来就OK

   ```java
   1)想画对象需要获取对象的图片，每个对象都能得图片，
     意味着获取图片的行为为共有行为，所以设计在SeaObject超类中，
     每个对象获取图片的代码都是不一样的，所以设计为抽象方法
     ---在SeaObject中设计抽象方法getImage()获取图片
   2)在派生类中重写getImage()获取对象所对应的图片
     ---在6个类中重写getImage()
   3)因为只有活着的对象才需要画到窗口中，所以需要设计对象的状态(活着还是死了)，
     每个对象都有状态，意味着状态为共有属性，所以设计在SeaObject超类中，
     状态一般都设计为常量，同时再设计state变量表示当前状态
     ---在SeaObject中设计LIVE、DEAD常量，state变量表示当前状态
     在后期的业务中经常需要判断对象的状态，每个对象都得判断，
     意味着判断状态的行为为共有行为，所以设计在SeaObject超类中，
     每个对象判断状态的代码都是一样的，所以设计为普通方法
     ---在SeaObject中设计isLive()、isDead()判断对象的状态
   4)数据(状态、图片、x坐标、y坐标)都有了就可以开画了，每个对象都得画，
     意味着画对象的行为为共有行为，所以设计在SeaObject超类中，
     每个对象画的代码都是一样的，所以在设计为普通方法
     ---在SeaObject中设计paintImage()画对象
   5)画对象的方法写好了，在窗口World类中调用即可:
     5.1)准备对象
     5.2)重写paint()方法(不要求掌握)----在paint()中调用paintImage()即可
   ```



## 回顾：

1. 方法的重写(override/overriding)：

   - 发生在父子类中，方法名相同，参数列表相同
   - 重写方法被调用时，看对象的类型-----------------------规定

2. package和import：

3. 访问控制修饰符：----------------保护数据的安全

   - public：公开的，任何类
   - protected：受保护的，本类、派生类、同包类
   - 默认的(default)：什么也不写，本类、同包类
   - private：私有的，本类

4. static：静态的

   - 静态变量：static，类，方法区中，一份，类名点，所有对象所共享的数据(图片、音频、视频等)

   - 静态方法：static，类，方法区中，一份，类名点，没有隐式this，所以不能直接访问实例成员

     ​                   方法的操作与对象无关(不需要访问对象的数据/对象的行为)

   - 静态块：static，类被加载时自动执行，一次，初始化/加载静态资源(图片、音频、视频等)



## 精华笔记：

1. final：最终的、不可改变的------------------应用率不高
   - 修饰变量：变量不能被改变
   - 修饰方法：方法不能被重写
   - 修饰类：类不能被继承
2. static final常量：应用率高
   - 必须声明同时初始化
   - 常常由类名点来访问，不能被改变
   - 建议：常量所有字母都大写，多个单词用_分隔
   - 编译器在编译时会将常量直接替换为具体的数，效率高
   - 何时用：数据永远不变，并且经常使用
3. 抽象方法：
   - 由abstract修饰
   - 只有方法的定义，没有具体的实现(连{}都没有)
4. 抽象类：  
   - 由abstract修饰
   - 包含抽象方法的类必须是抽象类
   - 抽象类不能被实例化(new对象)
   - 抽象类是需要被继承的，派生类：
     - 重写所有抽象方法-------------------变不完整为完整
     - 也声明为抽象类----------------------一般不这么做
   - 抽象类的意义：
     - 封装共有的属性和行为------------------代码复用
     - 为所有派生类提供统一的类型---------向上造型(代码复用)
     - 可以包括抽象方法，为所有派生类提供统一的入口(向上造型后能点出来)，同时达到强制重写的目的



## 笔记：

1. final：最终的、不可改变的------------------应用率不高

   - 修饰变量：变量不能被改变

     ```java
     class Aoo{
         final int num = 5;
         void test(){
             //num = 55; //编译错误，final的变量不能被改变
         }
     }
     ```

   - 修饰方法：方法不能被重写

     ```java
     class Boo{
         final void show(){}
         void test(){}
     }
     class Coo extends Boo{
         //void show(){} //编译错误，final的方法不能被重写
         void test(){}
     }
     ```

   - 修饰类：类不能被继承

     ```java
     final class Doo{}
     //class Eoo extends Doo{} //编译错误，final的类不能被继承
     class Foo{}
     final class Goo extends Foo{} //正确，不能当老爸，但能当儿子
     ```

2. static final常量：应用率高

   - 必须声明同时初始化

   - 常常由类名点来访问，不能被改变

   - 建议：常量所有字母都大写，多个单词用_分隔

   - 编译器在编译时会将常量直接替换为具体的数，效率高

   - 何时用：数据永远不变，并且经常使用

     ```java
     public class StaticFinalDemo {
         public static void main(String[] args) {
             System.out.println(Hoo.PI); //常常通过类名点来访问
             //Hoo.PI = 3.1415926; //编译错误，常量不能被改变
             
             //1)加载Ioo.class到方法区中
             //2)静态变量num一并存储到方法区中
             //3)到方法区中获取num的值并输出
             System.out.println(Ioo.num);
     
             //编译器在编译时会将常量直接替换为具体的值，效率高
             //相当于System.out.println(5);
             System.out.println(Ioo.COUNT);
         }
     }
     
     class Ioo{
         public static int num = 5; //静态变量
         public static final int COUNT = 5; //常量
     }
     
     class Hoo{
         public static final double PI = 3.14159;
         //public static final int NUM; //编译错误，常量必须声明同时初始化
     }
     ```

3. 抽象方法：

   - 由abstract修饰
   - 只有方法的定义，没有具体的实现(连{}都没有)

4. 抽象类：  

   - 由abstract修饰
   - 包含抽象方法的类必须是抽象类
   - 抽象类不能被实例化(new对象)
   - 抽象类是需要被继承的，派生类：
     - 重写所有抽象方法-------------------变不完整为完整
     - 也声明为抽象类----------------------一般不这么做
   - 抽象类的意义：
     - 封装共有的属性和行为------------------代码复用
     - 为所有派生类提供统一的类型---------向上造型(代码复用)
     - 可以包括抽象方法，为所有派生类提供统一的入口(向上造型后能点出来)，同时达到强制重写的目的



## 补充：

1. 设计规则：

   - 将派生类所共有的属性和行为，抽到超类中--------------------抽共性

   - 若派生类的行为/代码都一样，设计为普通方法

     若派生类的行为/代码不一样，设计为抽象方法

   - ......-----------------后天讲

2. 抽象方法/抽象类的疑问：

   - 抽象方法存在的意义是什么?
     - 保证当发生向上造型时，通过超类的引用能点出来那个方法---------------保证能点出来
   - 既然抽象方法的意义是保证能点出来，那为什么不设计为普通方法呢?
     - 设计为普通方法，意味着派生类可以重写也可以不重写，但设计为抽象方法，则可以强制派生类必须重写-----------强制派生类重写，以达到统一的目的

3. 画对象带数：先找main

   - 当创建(new)World对象时，就会分配World类中的实例变量(ship,submarines,mines,bombs)，对象的数据(width/height/x/y/speed)都在构造方法中赋好值了

   - frame.setVisible(true)时会自动调用paint()方法，在paint()中：当第1次用到Images类中，会将Images.class加载到方法区中，同时将那一堆静态图片分配到方法区中，同时自动执行静态块给图片赋值

   - ship.paintImage(g)时会去调用SeaObject中的paintImage()方法，方法中的this指的就是战舰ship，方法中先判断战舰是否是活着的，若活着则获取战舰的图片，用画笔画到战舰的x坐标和y坐标上

     submarines[i].paintImage(g)时会用调用SeaObject中的paintImage()方法，假设submarines[i]为侦察潜艇对象，则方法中的this指的就是侦察潜艇，方法中判断侦察潜艇是否是活着的，若活着则获取侦察潜艇图片，用画笔画到侦察潜艇的x坐标和y坐标上。假设submarines[i]为鱼雷潜艇对象，则......

4. 明日单词：

   ```java
   1)inner:内部的
   2)outer:外部的
   3)baby:孩子
   4)create:创建
   5)anonymous/anon:匿名
   6)shoot:射击
   7)next:下
   8)one:一个
   9)action:行动
   10)enter:进入
   11)timer:定时器
   12)interval:间隔
   13)schedule:日程表
   14)task:任务
   15)repaint:重新画
   ```

   

